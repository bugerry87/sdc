diff --git a/robot_pose_ekf/src/odom_estimation_node.cpp b/../robot_pose_ekf/src/odom_estimation_node.cpp
index dc9eb90..89f0763 100644
--- a/robot_pose_ekf/src/odom_estimation_node.cpp
+++ b/../robot_pose_ekf/src/odom_estimation_node.cpp
@@ -116,14 +116,14 @@ namespace estimation
     // subscribe to imu messages
     if (imu_used_){
       ROS_DEBUG("Imu sensor can be used");
-      imu_sub_ = nh.subscribe("imu_data", 10,  &OdomEstimationNode::imuCallback, this);
+      imu_sub_ = nh.subscribe("/imu_data", 10,  &OdomEstimationNode::imuCallback, this);
     }
     else ROS_DEBUG("Imu sensor will NOT be used");
 
     // subscribe to vo messages
     if (vo_used_){
       ROS_DEBUG("VO sensor can be used");
-      vo_sub_ = nh.subscribe("vo", 10, &OdomEstimationNode::voCallback, this);
+      vo_sub_ = nh.subscribe("/vo", 10, &OdomEstimationNode::voCallback, this);
     }
     else ROS_DEBUG("VO sensor will NOT be used");
 
@@ -223,6 +223,8 @@ namespace estimation
 
     assert(imu_used_);
 
+    std::cout<<"imu_data_callback"<<std::endl;
+
     // receive data 
     imu_stamp_ = imu->header.stamp;
     tf::Quaternion orientation;
@@ -233,7 +235,7 @@ namespace estimation
         imu_covariance_(i+1, j+1) = imu->orientation_covariance[3*i+j];
 
     // Transforms imu data to base_footprint frame
-    if (!robot_state_.waitForTransform(base_footprint_frame_, imu->header.frame_id, imu_stamp_, ros::Duration(0.5))){
+    /*if (!robot_state_.waitForTransform(base_footprint_frame_, imu->header.frame_id, imu_stamp_, ros::Duration(0.5))){
       // warn when imu was already activated, not when imu is not active yet
       if (imu_active_)
         ROS_ERROR("Could not transform imu message from %s to %s", imu->header.frame_id.c_str(), base_footprint_frame_.c_str());
@@ -242,10 +244,10 @@ namespace estimation
       else 
         ROS_DEBUG("Could not transform imu message from %s to %s. Imu will not be activated yet.", imu->header.frame_id.c_str(), base_footprint_frame_.c_str());
       return;
-    }
+    }*/
     StampedTransform base_imu_offset;
-    robot_state_.lookupTransform(base_footprint_frame_, imu->header.frame_id, imu_stamp_, base_imu_offset);
-    imu_meas_ = imu_meas_ * base_imu_offset;
+    //robot_state_.lookupTransform(base_footprint_frame_, imu->header.frame_id, imu_stamp_, base_imu_offset);
+    //imu_meas_ = imu_meas_ * base_imu_offset;
 
     imu_time_  = Time::now();
 
@@ -299,8 +301,15 @@ namespace estimation
     vo_time_  = Time::now();
     poseMsgToTF(vo->pose.pose, vo_meas_);
     for (unsigned int i=0; i<6; i++)
-      for (unsigned int j=0; j<6; j++)
-        vo_covariance_(i+1, j+1) = vo->pose.covariance[6*i+j];
+      for (unsigned int j=0; j<6; j++) {
+        vo_covariance_(i+1, j+1) = 0;
+        if (i == j && i <= 2) {
+          vo_covariance_(i+1, j+1) = 0.1;
+        }
+        else if (i == j && i > 2) {
+          vo_covariance_(i+1, j+1) = 0.17;
+        }
+      }
     my_filter_.addMeasurement(StampedTransform(vo_meas_.inverse(), vo_stamp_, base_footprint_frame_, "vo"), vo_covariance_);
     
     // activate vo
@@ -539,6 +548,7 @@ int main(int argc, char **argv)
 {
   // Initialize ROS
   ros::init(argc, argv, "robot_pose_ekf");
+   std::cout<<"imu_data_callback"<<std::endl;
 
   // create filter class
   OdomEstimationNode my_filter_node;
